# -*- coding:utf-8 -*-
import sys
import os
from os.path import join, abspath, realpath, dirname

pwd = dirname(realpath(__file__))
ROOT = os.path.join(pwd, "..")
sys.path.insert(0, ROOT)

from collections import deque
import asyncio
from enum import Enum
from typing import Optional, Union

import logging
_logger = logging.getLogger(__file__)

import time

from wechaty import (
    Contact,
    FileBox,
    Message,
    Wechaty,
    Room,
    ScanStatus,
)
from wechaty_puppet import MessageType

# Initialize a PaddleHub plato-mini model
import paddlehub as hub
MAX_CHAT_ROUNDS = 10
model = hub.Module(name='plato-mini', version='1.0.0')
model._interactive_mode = True
model.max_turn = MAX_CHAT_ROUNDS
model.context = deque(maxlen=model.max_turn)

from lxml import etree
from io import StringIO

# Initialize a command handling machine
from task.task_mgr_plugin import TaskMgrPlugin
from utils.extract_wechat_msg import split_quote_and_mention
from lib.log import init_logging, configure_logging, LoggerAdaptor
from config import settings

init_logging()
configure_logging(settings.LOGGING)

class MyBot(Wechaty):

    logger = LoggerAdaptor("MyBot", _logger)

    Rules = {
        'sysmsg' : "//sysmsg",
        'appmsg' : "//appmsg"
    }

    class State(Enum):
        UNDEFINED_STATE = -1
        CMD = 1
        RPC = 2
        CHATTING = 3
        WXAPI = 4

    def __init__(self):
        super().__init__()

        self.state = MyBot.State.UNDEFINED_STATE
        self.chat_rounds = 0

        self.master = None
        self.parser = etree.HTMLParser()
        # this should be cleared each round
        self.msg_type = ""

    async def my_self(self):
        if self.master == None:
            master_contact_id = self.contact_id
            contact = Contact.load(master_contact_id)
            await contact.ready()
            self.logger.info(f"load master : {contact}")
            self.master = contact
        return self.master

    def parse(self, txt):
        tree = etree.parse(StringIO(txt), parser=self.parser)
        if etree.tostring(tree) is None:
            raise Exception("Bad Values")
        return tree

    def get_msg_type(self, tree):
        for path in tree.xpath(self.Rules["sysmsg"]):
            attrs = path.attrib
            self.msg_type = attrs['type']
            return self.msg_type

        for path in tree.xpath(self.Rules["appmsg"]):
            attrs = path.attrib
            self.msg_type = "app_push"
            return self.msg_type


    def is_pat(self):
        if self.msg_type == "pat":
            return True
        else:
            return False

    def is_app_push(self):
        if self.msg_type == "app_push":
            return True
        else:
            return False


bot : Optional[MyBot] = None


async def on_message(msg: Message):
    """
    Message Handler for the Bot
    """

    # add customer logics
    self_contact = await bot.my_self()
    from_contact = msg.talker()
    txt = msg.text()

    # chatting info
    room = msg.room()

    if room is not None:
        return

    if isinstance(msg.text(), str) and len(msg.text()) > 0 \
        and msg._payload.type == MessageType.MESSAGE_TYPE_TEXT:

        if txt == "chat":
            bot_response = "%s switch state from %s to %s (not we are not going to respond in a chat room)" % (settings.BOT_PROLOG, bot.state, MyBot.State.CHATTING)
            bot.state = MyBot.State.CHATTING
            await msg.say(bot_response)

        if bot.state == MyBot.State.CHATTING:

            quoted, text, mention = split_quote_and_mention(txt)
            to_bot = self_contact.get_id() in msg.payload.mention_ids or \
                     self_contact.payload.name == mention
            if self_contact.get_id() != msg.payload.to_id:
                return
            if not to_bot:
                return
            conversation: Union[Room, Contact] = from_contact if room is None else room
            await conversation.ready()

            ### PaddleHub chatbot
            if bot.chat_rounds < MAX_CHAT_ROUNDS:
                bot_response = model.predict(data=msg.text())[0]
                bot.chat_rounds += 1
            else:
                bot_response = "exeeds maximum chatting rounds %d" % MAX_CHAT_ROUNDS
            bot_response = "%s %s" % (settings.BOT_PROLOG, bot_response)
            await conversation.say(bot_response)  # Return the text generated by PaddleHub chatbot
    ###


async def on_scan(
        qrcode: str,
        status: ScanStatus,
        _data,
):
    """
    Scan Handler for the Bot
    """
    print('Status: ' + str(status))
    print('View QR Code Online: https://wechaty.js.org/qrcode/' + qrcode)


async def on_login(user: Contact):
    """
    Login Handler for the Bot
    """
    print(f'user: {user} has login in')
    # TODO: To be written


async def main():
    """
    Async Main Entry
    """
    #
    # Make sure we have set WECHATY_PUPPET_SERVICE_TOKEN in the environment variables.
    #
    if 'WECHATY_PUPPET_SERVICE_TOKEN' not in os.environ:
        print('''
            Error: WECHATY_PUPPET_SERVICE_TOKEN is not found in the environment variables
            You need a TOKEN to run the Python Wechaty. Please goto our README for details
            https://github.com/wechaty/python-wechaty-getting-started/#wechaty_puppet_service_token
        ''')

    global bot
    bot = MyBot()

    bot.on('scan',      on_scan)
    bot.on('login',     on_login)
    bot.on('message',   on_message)

    bot.use(TaskMgrPlugin())
    await bot.start()


asyncio.run(main())
